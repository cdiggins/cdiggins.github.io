<html>
<head>
<title>Interactive Tester</title>
</head>
<style>
textarea { width:100%; }
</style>
<body>

<h1>Interactive Myna Tester</h1>

<p>
    Myna is a JavaScript library for <i>syntactic analysis</i>, i.e. <i><a href="https://en.wikipedia.org/wiki/Parsing">parsing</a></i>. 
    Myna parsers are <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">recursive descent parsers</a> that support 
    both back-tracking and look-ahead (table-based) techniques and can recognize any <i>context-free grammar</i> (CFG).
</p>

<h3>Sample Rules</h3>
<p>
    The following are a set of parsing rules from the various example grammars provided with Myna.
</p>

<select id="rules" onChange="ruleChanged()">    
    <option value='markdown.document'>markdown.document</option>
    <option value='json.object'>json.object</option>
    <option value='csv.file'>csv.file</option>
    <option value='arithmetic.expr'>arithmetic.expr</option>
</select>
<br/>

<h3>Myna Grammars</h3>
<p>
    A <i>grammar</i> is a set of parsing rules. In Myna any object that has member
    fields that are derived from the <code>Myna.Rule</code>
    class can be considered a grammar. A grammar should be registered with the Myna
    module using <code>Myna.registerGrammar</code>. This will automatically associate 
    a name with each rule and store the grammar and its rules in the Myna module.
</p>
<textarea spellcheck=false id="js-grammar" rows="20" cols="80">
</textarea>

<h3>Extended PEG Grammar Representation</h3>
<p>
    The following is a representation of the grammar using an extended variation of a <i>PEG</i> 
    (<i>Parsing Expression Grammar</i>). The Myna API extends the PEG formalism through the support of 
    the following features:
    <ul>
        <li>look-ahead operators</li>
        <li>character sets (and negated character sets)</li>
        <li>numerically bounded matches (e.g. between n and m matches)</li>
        <li>function-based actions and predicates</li>
    </ul>
</p>
<textarea spellcheck=false id="peg-grammar" rows="20" cols="80">
</textarea>

<h3>Abstract Syntax Tree Schema</h3>
<p>
    When certain rules in a grammar are successfully parsed they add a node to a parse-tree structure called an <i>abstract syntax tree</i>
    or <i>AST</i> for short. Rules that generate 
    nodes are copies of other rules created using the <code>.ast</code> property. Since only a subset of rules generate nodes in the AST 
    the tree strcuture has a similar but simpler shape as the grammar and is described using a <i>schema</i>. 
</p>
<textarea spellcheck=false id="schema" rows="20" cols="80">
</textarea>

<h3>Input Text</h3>
<select id="inputs" onChange="inputChanged()">
</select>
<input id="inputId" type="file" onchange="onChooseInput(event)" />
<br/>
<textarea spellcheck=false id="inputText" onChange="updateAst()" rows="20" cols="80">
</textarea>

<h3>Ast</h3>
<!--
<select id="strategy" onChange="selectStrategy()">
    <option value="matchBeginning">match beginning</option>
    <option value="matchEntire">match entire</option>
    <option value="findFirst">find first</option>
    <option value="findAll">find all</option>
    <option value="repeat">repeat</option>
</select>
-->
<br/>
<textarea spellcheck=false id="outputAst" rows="20" cols="80">
</textarea>

</body>
<script src="../myna.js"></script>
<script src="../grammars/csv.js"></script>
<script src="../grammars/json.js"></script>
<script src="../grammars/arithmetic.js"></script>
<script src="../grammars/markdown.js"></script>
<script src="../examples/arithmetic_evaluator.js"></script>  
<script src="myna_tester.js"></script>
<script src="tests.js"></script>
<script src="test_inputs.js"></script>
<script>
let currentRule = undefined;
let strategy = undefined; 

function createInputsList() {
    let elem = document.getElementById("inputs");
    let items = ["<option value=''>Choose input ...</option>"];
    for (let key in testInputs) 
        items.push("<option value='" + key + "'>" + key + "</option>");
    elem.innerHTML = items.join("\n");
}

function getGrammarFileName(grammarName) {
    return "..\\grammars\\" + grammarName + ".js";
}

function getGrammarFile(grammarName, onRead) {
    httpRead(getGrammarFileName(grammarName), onRead);
}

function selectGrammar(grammarName) {    
    let jsGrammarElem = document.getElementById("js-grammar");
    getGrammarFile(grammarName, function(text) { 
        jsGrammarElem.innerHTML = text; 
    });

    let pegGrammarElem = document.getElementById("peg-grammar");
    let pegGrammar = Myna.grammarToString(grammarName);
    pegGrammarElem.innerHTML = pegGrammar;

    let schemaElem = document.getElementById("schema");
    let schema = Myna.astSchemaToString(grammarName);
    schemaElem.innerHTML = schema;
}

function setRule(name) {
    currentRule = Myna.allRules[name];
    selectGrammar(currentRule.grammarName);
    updateAst();
}

function setInput(text) {
    let elem = document.getElementById('inputText');
    elem.value = text;
    updateAst();
}

function ruleChanged() {
    let select = document.getElementById('rules'); 
    let value = select.options[select.selectedIndex].value;
    if (value) 
        setRule(value);    
}

function inputChanged() {
    let select = document.getElementById('inputs'); 
    let value = select.options[select.selectedIndex].value;
    if (value) 
        setInput(testInputs[value]);
}

function astToString(ast) {
    result = "<" + ast.name + ">\n";
    if (ast.children != null && ast.children.length > 0)
        result += ast.children.map(astToString).join("\n");
    else 
        result += ast.selfText;    
    result += "</" + ast.name + ">\n";
    return result;
}

function grammarToString(grammarName) {    
    return Myna.grammarRules(grammarName).map(ruleToString).join('\n');
}

function httpRead(file, onRead) {
    let xhr = new XMLHttpRequest();
    xhr.open("GET", file, true);
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4 && (xhr.status === 200 || xhr.status == 0))
            onRead(xhr.responseText);            
    };
    xhr.send(null);
}

function onChooseInput(event) {
    onChooseFile(event, function(event) { setInput(event.target.result); });
}

function onChooseFile(event, onLoadFileHandler) {
    if (typeof window.FileReader !== 'function')
        throw ("The file API isn't supported on this browser.");
    let input = event.target;
    if (!input)
        throw ("The browser does not properly implement the event object");
    if (!input.files)
        throw ("This browser does not support the `files` property of the file input.");
    if (!input.files[0])
        return undefined;
    fileRead(input.files[0], onLoadFileHandler);
}

function updateAst() {
    let inputElem = document.getElementById('inputText');
    let outputElem = document.getElementById('outputAst');
    let ast = Myna.parse(currentRule, inputElem.value);
    outputElem.value = astToString(ast);
}

function selectStrategy() {
    let select = document.getElementById('strategy'); 
    let value = select.options[select.selectedIndex].value;
    strategy = value;
    updateAst();
}

Myna.registerGrammar("json", JsonGrammar);
Myna.registerGrammar("arithmetic", ArithmeticGrammar);
Myna.registerGrammar("csv", CsvGrammar);
Myna.registerGrammar("markdown", MarkdownGrammar);

createInputsList();
setRule("markdown.document");
setInput(testInputs["markdown"]);
</script>
</html>
